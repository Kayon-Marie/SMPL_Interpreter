package smpl.syntax.parser;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;

import smpl.syntax.lexer.SMPLLexer;

import smpl.syntax.ast.core.Exp;
import smpl.syntax.ast.core.SMPLProgram;
import smpl.syntax.ast.*;

/* Preliminaries to set up and use the scanner.  */
parser code {:
		SMPLLexer lexer;

		public SMPLParser(SMPLLexer l) {
		    // As of CUP v0.11, need to pass Lexer to superclass
		    super(l);
		    lexer = l;
		}

		public void report_error(String message, Object info) {
		    System.err.println(message);
		}

		public void syntax_error(Symbol cur_token) {
		    System.err.print("Line " + lexer.getLine() +
				     " near char " + lexer.getChar() + ": ");
		    report_error("Syntax error", cur_token);
		    System.err.println ("Last token read is " +
					 lexer.getText());
		}
	    :};

init with {:
	  :};

scan with {:
		try {
		    return lexer.next_token();
		} catch (java.io.IOException ioe) {
		    System.out.println("Line " + lexer.getLine() + ", pos " +
				       lexer.getChar() +
				       ": Unrecognised token");
		    System.out.println(ioe.getMessage());
		    throw ioe;
		}
	  :};

/* Terminals (tokens returned by the scanner). */

// special symbols
terminal LPAREN, RPAREN;

// arithmetic operators
terminal PLUS, MINUS, MUL, DIV, MOD, POWER;

//logical operators
terminal AND, OR, NOT;

// terminals with values
terminal Integer INT;
terminal String VAR;
terminal Double REAL;
terminal Boolean TRUE;
terminal Boolean FALSE;
terminal String RELOP;
terminal String ASSIGN;

/* Non terminals */
non terminal SMPLProgram program;
non terminal StmtSequence stmtList;
non terminal Statement stmt;
non terminal StmtDefinition definition;
non terminal Exp expression;
non terminal Exp term;
non terminal Exp factor;
non terminal Exp value;
non terminal Exp arithExp;
non terminal Exp relops;
non terminal String relsign;
non terminal Exp logops;
non terminal Exp bool;
// non terminal Exp relopSeq;
non terminal empty;

/* Grammar rules */

program ::=	stmtList:s {: RESULT = new SMPLProgram(s); :};

stmtList ::=	stmtList:lst stmt:s {:
					lst.add(s); 
					RESULT = lst;
				:} |
	     		stmt:s {:
					RESULT = new StmtSequence(s);
				:};

stmt ::=	definition:d {: RESULT = d; :} |
	 		expression:e {: RESULT = new Statement(e); :};

definition ::=	VAR:v ASSIGN expression:e {:
		   			RESULT = new StmtDefinition(v, e);
				:};

expression ::=	logops: l {: RESULT = l; :};

logops ::= 	logops: l AND relops: r {: RESULT = new ExpAnd(l, r); :} |
			logops: l OR relops: r {: RESULT = new ExpOr(l, r); :}	|
			relops: r {: RESULT = r; :};

relops ::= 	NOT arithExp: ae {: RESULT = new ExpNot(ae); :} |
			arithExp: ae {: RESULT = ae; :};

/*

relops ::= 	relops: r RELOP: sign arithExp: ae {:
				RESULT = r.add(ae, sign);
			:} |
			arithExp: ae {:
				RESULT = new ExpRelOps(ae);
			:};	

logop ::=	relop: left LOGOP: op relop: right {:
				RESULT = new ExpLogOp(left, right, op);
			:};

relop ::= 	arithExp: left RELOP: sign arithExp: right {:
				RESULT = new ExpRelOp(left, right, sign);
			:};
*/

arithExp ::=	arithExp:e PLUS term:t {:
					RESULT = new ExpAdd(e, t); :} |
				arithExp:e MINUS term:t {:
					RESULT = new ExpSub(e, t); :} |
				term:t {: RESULT = t; :};

term ::=	term:t MUL factor:f {:
				RESULT = new ExpMul(t, f); :} |
	 		term:t DIV factor:f {:
				RESULT = new ExpDiv(t, f); :} |
	 		term:t MOD factor:f {:
				RESULT = new ExpMod(t, f); :} |
			LPAREN MINUS factor: f RPAREN {:
				RESULT = new ExpNeg(f); :}	|
	 		factor:f {: RESULT = f; :};

factor ::=	factor:f POWER value:v {: RESULT = new ExpPow(f, v); :} |
			bool: b {: RESULT = b; :} |
			value:v {: RESULT = v; :};

bool ::= 	TRUE: t {: RESULT = new ExpBool(t); :} |
			FALSE: f {: RESULT = new ExpBool(f); :};
	   		
value ::=   INT:ilit {: RESULT = new ExpLit(ilit); :} |
			REAL:rlit {: RESULT = new ExpLit(rlit); :} |
			VAR:var {: RESULT = new ExpVar(var); :} |
			LPAREN expression:e RPAREN {: RESULT = e; :};

relsign ::= RELOP: sign {: RESULT = sign; :} |
			ASSIGN: sign {: RESULT = sign; :};
			
empty ::= ;